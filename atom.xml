<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hexo</title>
  
  
  <link href="/killery2.github.io/atom.xml" rel="self"/>
  
  <link href="https://18228164057.github.io/killery2.github.io/"/>
  <updated>2018-09-09T13:14:15.349Z</updated>
  <id>https://18228164057.github.io/killery2.github.io/</id>
  
  <author>
    <name>killer</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java八大排序算法</title>
    <link href="https://18228164057.github.io/killery2.github.io/2018/09/07/java%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://18228164057.github.io/killery2.github.io/2018/09/07/java八大排序算法/</id>
    <published>2018-09-07T13:13:31.000Z</published>
    <updated>2018-09-09T13:14:15.349Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a><font color="#dd0000">1.冒泡排序</font></h2><h3 id="冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。"><a href="#冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。" class="headerlink" title="冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。"></a>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> package Demo;</span><br><span class="line">/**</span><br><span class="line"> * 冒泡排序</span><br><span class="line"> * 比较相邻的元素。如果第一个比第二个大，就交换他们两个。  </span><br><span class="line"> * 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。  </span><br><span class="line"> * 针对所有的元素重复以上的步骤，除了最后一个。</span><br><span class="line"> * 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 </span><br><span class="line"> * @param numbers 需要排序的整型数组</span><br><span class="line"> */</span><br><span class="line">public class BubbleSort1 &#123;</span><br><span class="line">public static void bullleSort(int[] number)&#123;</span><br><span class="line">int temp=0;</span><br><span class="line"><span class="keyword">for</span>(int i=0;i&lt;number.length-1;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(int j=0;j&lt;number.length-1-i;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(number[j]&gt;number[j+1])&#123;</span><br><span class="line">temp=number[j];</span><br><span class="line">number[j]=number[j+1];</span><br><span class="line">number[j+1]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">BubbleSort1 sort = new BubbleSort1();</span><br><span class="line">int[] num = &#123;3,6,7,4,1,9,5,8,2&#125;;</span><br><span class="line">sort.bullleSort(num);</span><br><span class="line"><span class="keyword">for</span>(int a : num)&#123;</span><br><span class="line">System.out.print(<span class="string">" "</span> +a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2.选择排序"></a><font color="#dd0000">2.选择排序</font></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class <span class="built_in">test</span> &#123;  </span><br><span class="line">    public static void main(String[] numbersrgs) &#123;  </span><br><span class="line">        int [] numbers=&#123;6,2,4,1,9,8,3&#125;;  </span><br><span class="line">        SelectionSort(numbers);  </span><br><span class="line">        System.out.print(<span class="string">"选择排序结果为：  "</span>);  </span><br><span class="line">        <span class="keyword">for</span> (int i : numbers)  </span><br><span class="line">            System.out.print(i + <span class="string">" "</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    private static void SelectionSort(int [] numbers)&#123;  </span><br><span class="line">         int n = numbers.length;  </span><br><span class="line">            <span class="keyword">for</span> (int i = 0; i &lt; n; i++) &#123;  </span><br><span class="line">                int k = i;  </span><br><span class="line">                // 找出最小值的小标，找到之后赋值给K，numbers[k]即为最小值  </span><br><span class="line">                <span class="keyword">for</span> (int j = i + 1; j &lt; n; j++) &#123;  </span><br><span class="line">                    <span class="keyword">if</span> (numbers[j] &lt; numbers[k]) &#123;  </span><br><span class="line">                        k = j;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">                // 将最小值放到排序序列末尾  </span><br><span class="line">                <span class="keyword">if</span> (k &gt; i) &#123;  </span><br><span class="line">                    int tmp = numbers[i];  </span><br><span class="line">                    numbers[i] = numbers[k];  </span><br><span class="line">                    numbers[k] = tmp;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;     </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3.插入排序"></a><font color="#dd0000">3.插入排序</font></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class test2&#123;  </span><br><span class="line">    public static void main(String[] args) &#123;      </span><br><span class="line">        int [] nums=&#123;8,6,10,5,7,9,11&#125;;  </span><br><span class="line">        sortCore(nums);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    private static void sortCore(int[] array) &#123;  </span><br><span class="line">        int arraySize = array.length;  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (int i = 1; i &lt; arraySize; i++) &#123;  </span><br><span class="line">            int j = i;  </span><br><span class="line"></span><br><span class="line">            int waitInsert = array[i];  </span><br><span class="line">            <span class="keyword">while</span>(j &gt; 0 &amp;&amp; waitInsert &lt; array[j - 1]) &#123;  </span><br><span class="line">                array[j] = array[j - 1];  </span><br><span class="line">                j--;  </span><br><span class="line">            &#125;  </span><br><span class="line">            array[j] = waitInsert;  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">"最终的排序为："</span>);  </span><br><span class="line">        <span class="keyword">for</span>(int i:array)  </span><br><span class="line">            System.out.print(i+<span class="string">" "</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-归并排序"><a href="#4-归并排序" class="headerlink" title="4.归并排序"></a><font color="#dd0000">4.归并排序</font></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class test_cow &#123;  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        int [] numbers=&#123;6,2,4,1,9,8,3,15&#125;;  </span><br><span class="line">        sort(numbers);  </span><br><span class="line">        System.out.print(<span class="string">"归并排序的结果为："</span>);  </span><br><span class="line">        <span class="keyword">for</span>(int i:numbers)&#123;  </span><br><span class="line">            System.out.print(i+<span class="string">" "</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    public static void sort(int[] data) &#123;  </span><br><span class="line">        int[] temp = new int[data.length];  </span><br><span class="line">        mergeSort(data, temp, 0, data.length - 1);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    private static void mergeSort(int[] data, int[] temp, int left, int right) &#123;  </span><br><span class="line">        int mid = (left + right) / 2;  </span><br><span class="line">        <span class="keyword">if</span> (left == right)  </span><br><span class="line">            <span class="built_in">return</span>;  </span><br><span class="line">        mergeSort(data, temp, left, mid);  </span><br><span class="line">        mergeSort(data, temp, mid + 1, right);  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (int i = left; i &lt;= right; i++) &#123;  </span><br><span class="line">            temp[i] = data[i];  </span><br><span class="line">        &#125;  </span><br><span class="line">        int i1 = left;  </span><br><span class="line">        int i2 = mid + 1;  </span><br><span class="line">        <span class="keyword">for</span> (int cur = left; cur &lt;= right; cur++) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (i1 == mid + 1)  </span><br><span class="line">                data[cur] = temp[i2++];  </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i2 &gt; right)  </span><br><span class="line">                data[cur] = temp[i1++];  </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (temp[i1] &lt; temp[i2])  </span><br><span class="line">                data[cur] = temp[i1++];  </span><br><span class="line">            <span class="keyword">else</span>  </span><br><span class="line">                data[cur] = temp[i2++];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-堆排序"><a href="#5-堆排序" class="headerlink" title="5.堆排序"></a><font color="#dd0000">5.堆排序</font></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">public class test_sort &#123;  </span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        int[] nums = new int[] &#123; 5, 3, 6, 2, 1, 9, 4, 8, 7 &#125;;  </span><br><span class="line">        <span class="built_in">print</span>(nums);  </span><br><span class="line">        heapSort(nums);  </span><br><span class="line">        System.out.println(<span class="string">"排序后的数组："</span>);  </span><br><span class="line">        <span class="built_in">print</span>(nums);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    public static void swap(int[] data, int i, int j) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (i == j) &#123;  </span><br><span class="line">            <span class="built_in">return</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        data[i] = data[i] + data[j];  </span><br><span class="line">        data[j] = data[i] - data[j];  </span><br><span class="line">        data[i] = data[i] - data[j];  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    public static void heapSort(int[] data) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (int i = 0; i &lt; data.length; i++) &#123;  </span><br><span class="line">            createMaxdHeap(data, data.length - 1 - i);  </span><br><span class="line">            swap(data, 0, data.length - 1 - i);  </span><br><span class="line">            <span class="built_in">print</span>(data);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    public static void createMaxdHeap(int[] data, int lastIndex) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (int i = (lastIndex - 1) / 2; i &gt;= 0; i--) &#123;  </span><br><span class="line">            // 保存当前正在判断的节点  </span><br><span class="line">            int k = i;  </span><br><span class="line">            // 若当前节点的子节点存在  </span><br><span class="line">            <span class="keyword">while</span> (2 * k + 1 &lt;= lastIndex) &#123;  </span><br><span class="line">                // biggerIndex总是记录较大节点的值,先赋值为当前判断节点的左子节点  </span><br><span class="line">                int biggerIndex = 2 * k + 1;  </span><br><span class="line">                <span class="keyword">if</span> (biggerIndex &lt; lastIndex) &#123;  </span><br><span class="line">                    // 若右子节点存在，否则此时biggerIndex应该等于 lastIndex  </span><br><span class="line">                    <span class="keyword">if</span> (data[biggerIndex] &lt; data[biggerIndex + 1]) &#123;  </span><br><span class="line">                        // 若右子节点值比左子节点值大，则biggerIndex记录的是右子节点的值  </span><br><span class="line">                        biggerIndex++;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">if</span> (data[k] &lt; data[biggerIndex]) &#123;  </span><br><span class="line">                    // 若当前节点值比子节点最大值小，则交换2者得值，交换后将biggerIndex值赋值给k  </span><br><span class="line">                    swap(data, k, biggerIndex);  </span><br><span class="line">                    k = biggerIndex;  </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                    <span class="built_in">break</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    public static void <span class="built_in">print</span>(int[] data) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (int i = 0; i &lt; data.length; i++) &#123;  </span><br><span class="line">            System.out.print(data[i] + <span class="string">" "</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-希尔排序"><a href="#6-希尔排序" class="headerlink" title="6.希尔排序"></a><font color="#dd0000">6.希尔排序</font></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public class test_sort &#123;  </span><br><span class="line">    public static int count = 0;  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line"></span><br><span class="line">        int[] nums = new int[] &#123; 5, 3, 6, 2, 1, 9, 4, 8, 7 &#125;;  </span><br><span class="line">        <span class="built_in">print</span>(nums);  </span><br><span class="line">        shellSort(nums);  </span><br><span class="line">        System.out.println(<span class="string">"希尔排序最终结果为："</span>);  </span><br><span class="line">        <span class="built_in">print</span>(nums);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    public static void shellSort(int[] data) &#123;  </span><br><span class="line">        // 计算出最大的h值  </span><br><span class="line">        int h = 1;  </span><br><span class="line">        <span class="keyword">while</span> (h &lt;= data.length / 3) &#123;  </span><br><span class="line">            h = h * 3 + 1;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">while</span> (h &gt; 0) &#123;  </span><br><span class="line">            <span class="keyword">for</span> (int i = h; i &lt; data.length; i += h) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (data[i] &lt; data[i - h]) &#123;  </span><br><span class="line">                    int tmp = data[i];  </span><br><span class="line">                    int j = i - h;  </span><br><span class="line">                    <span class="keyword">while</span> (j &gt;= 0 &amp;&amp; data[j] &gt; tmp) &#123;  </span><br><span class="line">                        data[j + h] = data[j];  </span><br><span class="line">                        j -= h;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    data[j + h] = tmp;  </span><br><span class="line">                    <span class="built_in">print</span>(data);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            // 计算出下一个h值  </span><br><span class="line">            h = (h - 1) / 3;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    public static void <span class="built_in">print</span>(int[] data) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (int i = 0; i &lt; data.length; i++) &#123;  </span><br><span class="line">            System.out.print(data[i] + <span class="string">"\t"</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println();  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-基数排序"><a href="#7-基数排序" class="headerlink" title="7.基数排序"></a><font color="#dd0000">7.基数排序</font></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;  </span><br><span class="line"></span><br><span class="line">public class test_sort &#123;  </span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        int[] nums = new int[] &#123; 102, 52, 21, 12, 23 ,1,50,63,5,98&#125;;  </span><br><span class="line">        <span class="built_in">print</span>(nums);  </span><br><span class="line">        radixSort(nums, 10, 4);  </span><br><span class="line">        System.out.println(<span class="string">"基数排序后的数组："</span>);  </span><br><span class="line">        <span class="built_in">print</span>(nums);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    public static void radixSort(int[] data, int radix, int d) &#123;  </span><br><span class="line">        // 缓存数组  </span><br><span class="line">        int[] tmp = new int[data.length];  </span><br><span class="line">        // buckets用于记录待排序元素的信息  </span><br><span class="line">        // buckets数组定义了max-min个桶  </span><br><span class="line">        int[] buckets = new int[radix];  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (int i = 0, rate = 1; i &lt; d; i++) &#123;  </span><br><span class="line"></span><br><span class="line">            // 重置count数组，开始统计下一个关键字  </span><br><span class="line">            Arrays.fill(buckets, 0);  </span><br><span class="line">            // 将data中的元素完全复制到tmp数组中  </span><br><span class="line">            System.arraycopy(data, 0, tmp, 0, data.length);  </span><br><span class="line"></span><br><span class="line">            // 计算每个待排序数据的子关键字  </span><br><span class="line">            <span class="keyword">for</span> (int j = 0; j &lt; data.length; j++) &#123;  </span><br><span class="line">                int subKey = (tmp[j] / rate) % radix;  </span><br><span class="line">                buckets[subKey]++;  </span><br><span class="line">            &#125;  </span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (int j = 1; j &lt; radix; j++) &#123;  </span><br><span class="line">                buckets[j] = buckets[j] + buckets[j - 1];  </span><br><span class="line">            &#125;  </span><br><span class="line"></span><br><span class="line">            // 按子关键字对指定的数据进行排序  </span><br><span class="line">            <span class="keyword">for</span> (int m = data.length - 1; m &gt;= 0; m--) &#123;  </span><br><span class="line">                int subKey = (tmp[m] / rate) % radix;  </span><br><span class="line">                data[--buckets[subKey]] = tmp[m];  </span><br><span class="line">            &#125;  </span><br><span class="line">            rate *= radix;  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    public static void <span class="built_in">print</span>(int[] data) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (int i = 0; i &lt; data.length; i++) &#123;  </span><br><span class="line">            System.out.print(data[i] + <span class="string">"\t"</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println();  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-快速排序"><a href="#8-快速排序" class="headerlink" title="8.快速排序"></a><font color="#dd0000">8.快速排序</font></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">/* 基于分治的思想，是冒泡排序的改进型 </span><br><span class="line"> * 快速排序和归并排序都使用分治法来设计算法，区别在于归并排序把数组分为两个基本等长的子数组， </span><br><span class="line"> * 分别排好序之后还要进行归并(Merge)操作，而快速排序拆分子数组的时候显得更有艺术，取一个基准元素， </span><br><span class="line"> * 拆分之后基准元素左边的元素都比基准元素小，右边的元素都不小于基准元素，这样只需要分别对两个子数组排序即可， </span><br><span class="line"> * 不再像归并排序一样需要归并操作。 </span><br><span class="line"> * */  </span><br><span class="line">public class test_cow&#123;  </span><br><span class="line"></span><br><span class="line">    public static void main(String []args)&#123;  </span><br><span class="line">       int[] nums = &#123;6,2,4,1,9,8,3,15&#125;;  </span><br><span class="line">       int start = 0;  </span><br><span class="line">       int end = nums.length-1;  </span><br><span class="line">       sort(nums,start,end);  </span><br><span class="line">       System.out.print(<span class="string">"快速排序后的结果为："</span>);  </span><br><span class="line">       <span class="keyword">for</span>(int i:nums)&#123;  </span><br><span class="line">            System.out.print(i+<span class="string">" "</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    private static void sort(int[] a,int low,int high)&#123;  </span><br><span class="line">        int start = low;  </span><br><span class="line">        int end = high;  </span><br><span class="line">        int key = a[low];  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(end&gt;start)&#123;                    //从后往前比较  </span><br><span class="line">            <span class="keyword">while</span>(end&gt;start&amp;&amp;a[end]&gt;=key)   //如果没有比关键值小的，比较下一个，直到有比关键值小的交换位置，然后又从前往后比较  </span><br><span class="line">                end--;  </span><br><span class="line">            <span class="keyword">if</span>(a[end]&lt;=key)&#123;  </span><br><span class="line">                int temp = a[end];  </span><br><span class="line">                a[end] = a[start];  </span><br><span class="line">                a[start] = temp;  </span><br><span class="line">            &#125;  </span><br><span class="line">            //从前往后比较  </span><br><span class="line">            <span class="keyword">while</span>(end&gt;start&amp;&amp;a[start]&lt;=key)//如果没有比关键值大的，比较下一个，直到有比关键值大的交换位置  </span><br><span class="line">               start++;  </span><br><span class="line">            <span class="keyword">if</span>(a[start]&gt;=key)&#123;  </span><br><span class="line">                int temp = a[start];  </span><br><span class="line">                a[start] = a[end];  </span><br><span class="line">                a[end] = temp;  </span><br><span class="line">            &#125;  </span><br><span class="line">        //  此时第一次循环比较结束，关键值的位置已经确定了。左边的值都比关键值小，右边的值都比关键值大，  </span><br><span class="line">        //  但是两边的顺序还有可能是不一样的，进行下面的递归调用  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(start&gt;low) sort(a,low,start-1);//左边序列。第一个索引位置到关键值索引-1  </span><br><span class="line">        <span class="keyword">if</span>(end&lt;high) sort(a,end+1,high);//右边序列。从关键值索引+1到最后一个  </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-冒泡排序&quot;&gt;&lt;a href=&quot;#1-冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;1.冒泡排序&quot;&gt;&lt;/a&gt;&lt;font color=&quot;#dd0000&quot;&gt;1.冒泡排序&lt;/font&gt;&lt;/h2&gt;&lt;h3 id=&quot;冒泡排序是一种简单的排序算法。它重复地走
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>面试题积累</title>
    <link href="https://18228164057.github.io/killery2.github.io/2018/09/07/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%A7%AF%E7%B4%AF/"/>
    <id>https://18228164057.github.io/killery2.github.io/2018/09/07/面试题积累/</id>
    <published>2018-09-07T13:03:12.000Z</published>
    <updated>2018-09-07T13:12:59.806Z</updated>
    
    <content type="html"><![CDATA[<h3 id="线程之间如何实现同步"><a href="#线程之间如何实现同步" class="headerlink" title="线程之间如何实现同步"></a>线程之间如何实现同步</h3><h3 id="cookie和session的区别和用法"><a href="#cookie和session的区别和用法" class="headerlink" title="cookie和session的区别和用法"></a>cookie和session的区别和用法</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;线程之间如何实现同步&quot;&gt;&lt;a href=&quot;#线程之间如何实现同步&quot; class=&quot;headerlink&quot; title=&quot;线程之间如何实现同步&quot;&gt;&lt;/a&gt;线程之间如何实现同步&lt;/h3&gt;&lt;h3 id=&quot;cookie和session的区别和用法&quot;&gt;&lt;a href=&quot;#c
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java面试基础题</title>
    <link href="https://18228164057.github.io/killery2.github.io/2018/04/04/Java%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80%E9%A2%98/"/>
    <id>https://18228164057.github.io/killery2.github.io/2018/04/04/Java面试基础题/</id>
    <published>2018-04-04T06:32:11.000Z</published>
    <updated>2018-04-14T13:58:06.766Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、面向对象的特征有哪些方面？"><a href="#1、面向对象的特征有哪些方面？" class="headerlink" title="1、面向对象的特征有哪些方面？"></a>1、面向对象的特征有哪些方面？</h3><blockquote><p>答：面向对象的特征主要有以下几个方面：<br>  <font color="#dd0000">抽象：</font><font face="黑体">抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。<br>  <font color="#dd0000">继承：</font>继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段（如果不能理解请阅读阎宏博士的《Java与模式》或《设计模式精解》中关于桥梁模式的部分）。<br>  <font color="#dd0000">封装：</font>通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口（可以想想普通洗衣机和全自动洗衣机的差别，明显全自动洗衣机封装更好因此操作起来更简单；我们现在使用的智能手机也是封装得足够好的，因为几个按键就搞定了所有的事情）。<br>  <font color="#dd0000">多态性：</font>多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。如果将对象的方法视为对象向外界提供的服务，那么运行时的多态性可以解释为：当A系统访问B系统提供的服务时，B系统有多种提供服务的方式，但一切对A系统来说都是透明的（就像电动剃须刀是A系统，它的供电系统是B系统，B系统可以使用电池供电或者用交流电，甚至还有可能是太阳能，A系统只会通过B类对象调用供电的方法，但并不知道供电系统的底层实现是什么，究竟通过何种方式获得了动力）。方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：1). 方法重写（子类继承父类并重写父类中已有的或抽象的方法）；2). 对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。</font>   </p></blockquote><h3 id="2、访问修饰符public-private-protected-以及不写（默认）时的区别？"><a href="#2、访问修饰符public-private-protected-以及不写（默认）时的区别？" class="headerlink" title="2、访问修饰符public,private,protected,以及不写（默认）时的区别？"></a>2、访问修饰符public,private,protected,以及不写（默认）时的区别？</h3><p><img src="https://i.loli.net/2018/04/04/5ac4761325252.jpg" alt="范围">   </p><blockquote><p>类的成员不写访问修饰时默认为default。默认对于同一个包中的其他类相当于公开（public），对于不是同一个包中的其他类相当于私有（private）。受保护（protected）对子类相当于公开，对不是同一包中的没有父子关系的类相当于私有。Java中，外部类的修饰符只能是public或默认，类的成员（包括内部类）的修饰符可以是以上四种。   </p></blockquote><h3 id="3、String-是最基本的数据类型吗？"><a href="#3、String-是最基本的数据类型吗？" class="headerlink" title="3、String 是最基本的数据类型吗？"></a>3、String 是最基本的数据类型吗？</h3><blockquote><p>答：不是。Java中的<font color="#dd0000">基本数据类型</font>只有8个：<font color="#dd0000">byte、short、int、long、float、double、char、boolean；</font>除了基本类型（primitive type）和枚举类型（enumeration type），剩下的都是引用类型（reference type）。   </p></blockquote><h3 id="4、float-f-3-4-是否正确？"><a href="#4、float-f-3-4-是否正确？" class="headerlink" title="4、float f=3.4;是否正确？"></a>4、float f=3.4;是否正确？</h3><blockquote><p>答:不正确。3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f =(float)3.4; 或者写成float f =3.4F;。   </p></blockquote><h3 id="5、short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗？"><a href="#5、short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗？" class="headerlink" title="5、short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗？"></a>5、short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗？</h3><blockquote><p>答：对于short s1 = 1; s1 = s1 + 1;由于1是int类型，因此s1+1运算结果也是int 型，需要强制转换类型才能赋值给short型。而short s1 = 1; s1 += 1;可以正确编译，因为s1+= 1;相当于s1 = (short)(s1 + 1);其中有隐含的强制类型转换。</p></blockquote><h3 id="6、Java有没有goto？"><a href="#6、Java有没有goto？" class="headerlink" title="6、Java有没有goto？"></a>6、Java有没有goto？</h3><blockquote><p>答：goto 是Java中的保留字，在目前版本的Java中没有使用。（根据James Gosling（Java之父）编写的《The Java Programming Language》一书的附录中给出了一个Java关键字列表，其中有goto和const，但是这两个是目前无法使用的关键字，因此有些地方将其称之为保留字，其实保留字这个词应该有更广泛的意义，因为熟悉C语言的程序员都知道，在系统类库中使用过的有特殊意义的单词或单词的组合都被视为保留字） </p></blockquote><h3 id="7、int和Integer有什么区别？"><a href="#7、int和Integer有什么区别？" class="headerlink" title="7、int和Integer有什么区别？"></a>7、int和Integer有什么区别？</h3><blockquote><p>答：Java是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型（wrapper class），int的包装类就是Integer，从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。<br>Java 为每个原始类型提供了包装类型：<br>原始类型: boolean，char，byte，short，int，long，float，double<br>包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</p></blockquote><h3 id="8、-amp-和-amp-amp-的区别？"><a href="#8、-amp-和-amp-amp-的区别？" class="headerlink" title="8、&amp;和&amp;&amp;的区别？"></a>8、&amp;和&amp;&amp;的区别？</h3><blockquote><p>答：&amp;运算符有两种用法：(1)按位与；(2)逻辑与。&amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true。&amp;&amp;之所以称为短路运算是因为，如果&amp;&amp;左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。很多时候我们可能都需要用&amp;&amp;而不是&amp;，例如在验证用户登录时判定用户名不是null而且不是空字符串，应当写为：username != null &amp;&amp;!username.equals(“”)，二者的顺序不能交换，更不能用&amp;运算符，因为第一个条件如果不成立，根本不能进行字符串的equals比较，否则会产生NullPointerException异常。注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。 </p></blockquote><p>这是一个代码区块：</p><pre><code>public static void main(){    system.sava}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、面向对象的特征有哪些方面？&quot;&gt;&lt;a href=&quot;#1、面向对象的特征有哪些方面？&quot; class=&quot;headerlink&quot; title=&quot;1、面向对象的特征有哪些方面？&quot;&gt;&lt;/a&gt;1、面向对象的特征有哪些方面？&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;答：面向对
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>images</title>
    <link href="https://18228164057.github.io/killery2.github.io/2018/04/03/images/"/>
    <id>https://18228164057.github.io/killery2.github.io/2018/04/03/images/</id>
    <published>2018-04-03T06:46:27.000Z</published>
    <updated>2018-04-16T09:42:12.420Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2018/04/03/5ac326491776d.jpg" alt="a">   </p><p><img src="https://i.loli.net/2018/04/03/5ac32695d24e7.jpg" alt="b">   </p><p><img src="https://i.loli.net/2018/04/03/5ac326fd8b8d8.jpg" alt="c">   </p><p><img src="https://i.loli.net/2018/04/03/5ac327003b40b.jpg" alt="d">    </p><p><img src="https://i.loli.net/2018/04/03/5ac3270074bc8.jpg" alt="e">   </p><p><img src="https://i.loli.net/2018/04/03/5ac327013f23a.jpg" alt="f">     </p><p><img src="https://i.loli.net/2018/04/03/5ac32701ba706.jpg" alt="h">   </p><p><img src="https://i.loli.net/2018/04/03/5ac3270257ec9.jpg" alt="i">   </p><p><img src="https://i.loli.net/2018/04/03/5ac327025e31a.jpg" alt="j">   </p><p><img src="https://i.loli.net/2018/04/03/5ac327029dc16.jpg" alt="k"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/04/03/5ac326491776d.jpg&quot; alt=&quot;a&quot;&gt;   &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/04/03/5ac32695d24e7.jpg&quot; 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java之并发编程底层实现原理</title>
    <link href="https://18228164057.github.io/killery2.github.io/2018/03/28/java%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://18228164057.github.io/killery2.github.io/2018/03/28/java之并发编程底层实现原理/</id>
    <published>2018-03-28T13:31:55.000Z</published>
    <updated>2018-04-13T13:35:08.586Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JAVA内存模型（java-memory-model）"><a href="#JAVA内存模型（java-memory-model）" class="headerlink" title="JAVA内存模型（java memory model）"></a><a href="http://www.importnew.com/19612.html" target="_blank" rel="noopener">JAVA内存模型（java memory model）</a></h2><p><img src="https://i.loli.net/2018/04/02/5ac224f32f997.jpg" alt="java内存模型"></p><h3 id="并发编程模型的两个关键问题"><a href="#并发编程模型的两个关键问题" class="headerlink" title="并发编程模型的两个关键问题"></a>并发编程模型的两个关键问题</h3><ul><li>线程之间如何通信以及线程之间如何同步（这里的线程是指并发执行的活动实体）。</li><li><p>通信是指线程之间以何种机制来交换信息。在命令式编程中，线程的通信机制有两种：共享内存和消息传递。</p><h2 id="volatile的应用"><a href="#volatile的应用" class="headerlink" title="volatile的应用"></a><a href="http://www.importnew.com/18126.html" target="_blank" rel="noopener">volatile</a>的应用</h2><h4 id="volatile的特性"><a href="#volatile的特性" class="headerlink" title="volatile的特性"></a>volatile的特性</h4><p> 理解volatile特性的好方法是把对 volatile变量的单个读/写，看成是使用同一个锁对这些单个读/写操作做了同步。下面通过具体的示例来说明：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class VolatileFeaturesExample&#123;</span><br><span class="line">    volatile long vl = 0L;</span><br><span class="line"> </span><br><span class="line"> public void <span class="built_in">set</span>(long l)&#123;</span><br><span class="line">     vl = 1;</span><br><span class="line"> &#125;</span><br><span class="line"> public void <span class="function"><span class="title">getAndIncrement</span></span>()&#123;</span><br><span class="line">     vl++;</span><br><span class="line"> &#125; </span><br><span class="line"> public long <span class="function"><span class="title">get</span></span>()&#123;</span><br><span class="line">     <span class="built_in">return</span> vl;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 假设有多个线程分别调用上面的程序的3个方法，这个程序在语义上和下面的程序等价。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class VolatileFeaturesExample&#123;</span><br><span class="line">    long vl = 0L;</span><br><span class="line"> </span><br><span class="line"> public synchronized void <span class="built_in">set</span>(long l)&#123;</span><br><span class="line">     vl = 1;</span><br><span class="line">    &#125;</span><br><span class="line"> public void <span class="function"><span class="title">getAndIncrement</span></span>()&#123;</span><br><span class="line">     long temp = get();</span><br><span class="line">        temp += 1L;</span><br><span class="line">        <span class="built_in">set</span>(temp); </span><br><span class="line"> &#125;</span><br><span class="line"> public synchronized long <span class="function"><span class="title">get</span></span>()&#123;</span><br><span class="line">     <span class="built_in">return</span> vl;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 如上面示例程序所示，一个volatile变量的单个读/写操作，与一个普通变量的读/写操作都是使用同一个锁同步，它们之间的执行效果相同。</p><h4 id="volatile实现可见性"><a href="#volatile实现可见性" class="headerlink" title="volatile实现可见性"></a>volatile实现可见性</h4></li></ul><ul><li>能够保证volatile变量的可见性。</li><li>不能保证volatile变量复合操作的原子性。<h6 id="如何实现？-通过加入内存屏障和禁止重排序优化来实现。"><a href="#如何实现？-通过加入内存屏障和禁止重排序优化来实现。" class="headerlink" title="如何实现？ 通过加入内存屏障和禁止重排序优化来实现。"></a>如何实现？ 通过加入内存屏障和禁止重排序优化来实现。</h6></li></ul><ul><li>对volatile变量执行写操作时，会在写操作后加入一条Store屏障指令。</li><li>对volatile变量执行读操作时，会在读操作前加入一条load屏障指令。<h2 id="synchronized-重量级锁-的应用"><a href="#synchronized-重量级锁-的应用" class="headerlink" title="synchronized(重量级锁)的应用"></a><a href="http://www.importnew.com/21866.html" target="_blank" rel="noopener">synchronized</a>(重量级锁)的应用</h2> 先来看下synchronized实现同步的基础：Java中的每一个对象都可以作为锁。具体表现为以下3种形式。</li><li>对于普通同步方法，锁是当前示例对象。</li><li>对于静态同步方法，锁是当前类的Class对象。</li><li>对于同步方法块，锁是Synchronized括号里配置的对象。<h4 id="JMM关于synchronized的两条规定"><a href="#JMM关于synchronized的两条规定" class="headerlink" title="JMM关于synchronized的两条规定"></a>JMM关于synchronized的两条规定</h4></li><li>线程解锁前，必须把共享变量的最新值刷新到主内存中去。</li><li>线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值（加锁与解锁需要是同一把锁）。<br>通过两条规定，保证了线程解锁前对共享变量的修改在下次加锁前对其他线程可见。<h4 id="线程执行互斥锁的过程："><a href="#线程执行互斥锁的过程：" class="headerlink" title="线程执行互斥锁的过程："></a>线程执行互斥锁的过程：</h4></li><li>获得互斥锁</li><li>清空工作</li><li>从主内存中拷贝变量的最新副本到工作内存</li><li>执行代码</li><li>将更改后的共享变量刷新到主内存</li><li>释放互斥锁<br> 用法示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class SyncThread implements Runnable &#123;</span><br><span class="line">   private static int count;</span><br><span class="line"> </span><br><span class="line">   public <span class="function"><span class="title">SyncThread</span></span>() &#123;</span><br><span class="line">      count = 0;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public  void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">      synchronized(this) &#123;</span><br><span class="line">         <span class="keyword">for</span> (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">               System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + (count++));</span><br><span class="line">               Thread.sleep(100);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public int <span class="function"><span class="title">getCount</span></span>() &#123;</span><br><span class="line">      <span class="built_in">return</span> count;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>synchronized的调用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SyncThread syncThread = new SyncThread();</span><br><span class="line">Thread thread1 = new Thread(syncThread, <span class="string">"SyncThread1"</span>);</span><br><span class="line">Thread thread2 = new Thread(syncThread, <span class="string">"SyncThread2"</span>);</span><br><span class="line">thread1.start();</span><br><span class="line">thread2.start();</span><br></pre></td></tr></table></figure></p><blockquote><p>  结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SyncThread1:0</span><br><span class="line">SyncThread1:1</span><br><span class="line">SyncThread1:2</span><br><span class="line">SyncThread1:3</span><br><span class="line">SyncThread1:4</span><br><span class="line">SyncThread2:5</span><br><span class="line">SyncThread2:6</span><br><span class="line">SyncThread2:7</span><br><span class="line">SyncThread2:8</span><br><span class="line">SyncThread2:9*</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p> 当两个并发线程(thread1和thread2)访问同一个对象(syncThread)中的synchronized代码块时，在同一时刻只能有一个线程得到执行，另一个线程受阻塞，必须等待当前线程执行完这个代码块以后才能执行该代码块。Thread1和thread2是互斥的，因为在执行synchronized代码块时会锁定当前的对象，只有执行完该代码块才能释放该对象锁，下一个线程才能执行并锁定该对象。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p> 本文对Java 并发编程中的理论基础进行了讲解，有些东西在后续的分析中还会做更详细的讨论，如可见性、顺序性等。后续的文章都会以本章内容作为理论基础来讨论。如果大家能够很好的理解上述内容，相信无论是去理解其他并发编程的文章还是在平时的并发编程的工作中，都能够对大家有很好的帮助。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JAVA内存模型（java-memory-model）&quot;&gt;&lt;a href=&quot;#JAVA内存模型（java-memory-model）&quot; class=&quot;headerlink&quot; title=&quot;JAVA内存模型（java memory model）&quot;&gt;&lt;/a&gt;&lt;a hr
      
    
    </summary>
    
    
  </entry>
  
</feed>
